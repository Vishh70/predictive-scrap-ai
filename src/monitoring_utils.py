from __future__ import annotations

import json
from pathlib import Path
from typing import Any, Dict, Optional

import pandas as pd


MONITOR_RULES: Dict[str, Dict[str, Any]] = {
    "Cushion": {
        "threshold": 0.5,
        "criticality": "CRITICAL",
        "tooltip": "Influences part filling/quality.",
        "message": "Check Part Filling/Quality",
    },
    "Injection_time": {
        "threshold": 0.03,
        "criticality": "CRITICAL",
        "tooltip": "Process instability detected.",
        "message": "Process Instability Detected",
    },
    "Dosage_time": {
        "threshold": 1.0,
        "criticality": "CRITICAL",
        "tooltip": "Check material feeding.",
        "message": "Check Material Feeding/Dosing Speed",
    },
    "Injection_pressure": {
        "threshold": 100.0,
        "criticality": "WARNING",
        "tooltip": "Check injection speed.",
        "message": "Injection pressure drift detected.",
    },
    "Switch_pressure": {
        "threshold": 100.0,
        "criticality": "WARNING",
        "tooltip": "",
        "message": "Switch pressure drift detected.",
    },
    "Switch_position": {
        "threshold": 0.05,
        "criticality": "WARNING",
        "tooltip": "",
        "message": "Switch-over position drift detected.",
    },
    "Cyl_tmp_z*": {
        "threshold": 5.0,
        "criticality": "WARNING",
        "tooltip": "Heating Zone stability check.",
        "message": "Heating Zone temperature drift detected.",
    },
}

IGNORED_COLUMNS = {
    "Extruder_torque",
    "Peak_pressure_time",
    "Peak_pressure_position",
    "Ejector_fix_deviation_torque",
}

BASE_DIR = Path(__file__).resolve().parent.parent
MONITORING_CONFIG_PATH = BASE_DIR / "data" / "monitoring_config.json"


def load_threshold_overrides(config_path: Path = MONITORING_CONFIG_PATH) -> Dict[str, float]:
    """
    Load threshold overrides from JSON config generated by rules_engine.
    Expected format:
      {
        "cushion": {"threshold": 0.5, ...},
        "injection_time": {"threshold": 0.03, ...}
      }
    """
    if not config_path.exists():
        return {}

    try:
        raw = json.loads(config_path.read_text(encoding="utf-8"))
    except Exception:
        return {}

    overrides: Dict[str, float] = {}
    if not isinstance(raw, dict):
        return overrides

    for key, value in raw.items():
        threshold: Optional[float] = None
        if isinstance(value, dict):
            threshold = value.get("threshold")
        elif isinstance(value, (int, float)):
            threshold = float(value)

        try:
            if threshold is None:
                continue
            overrides[str(key).strip().lower()] = float(threshold)
        except Exception:
            continue

    return overrides


class ProcessMonitor:
    """Industrial process monitor for threshold-based live safety checks."""

    def __init__(
        self,
        rules: Optional[Dict[str, Dict[str, Any]]] = None,
        ignored_columns: Optional[set[str]] = None,
    ) -> None:
        self.rules = rules or MONITOR_RULES
        self.ignored_columns = {
            self._normalize_name(c) for c in (ignored_columns or IGNORED_COLUMNS)
        }
        self._normalized_rules = {
            self._normalize_name(name): dict(rule) for name, rule in self.rules.items()
        }
        self._alias_to_rule = {
            "plasticizing_time": "dosage_time",
            "switch_over_volume": "switch_position",
        }
        self._apply_threshold_overrides(load_threshold_overrides())

    @staticmethod
    def _normalize_name(name: Any) -> str:
        text = str(name).strip().lower()
        if not text:
            return ""
        return (
            text.replace(" ", "_")
            .replace("-", "_")
            .replace("/", "_")
            .replace("(", "")
            .replace(")", "")
            .replace(".", "")
        )

    @staticmethod
    def _to_float(value: Any) -> Optional[float]:
        try:
            if value is None:
                return None
            if isinstance(value, str):
                value = value.strip().replace(",", ".")
                if value == "":
                    return None
            numeric = float(value)
            if pd.isna(numeric):
                return None
            return numeric
        except Exception:
            return None

    def _resolve_rule_key(self, normalized_param: str) -> Optional[str]:
        if not normalized_param:
            return None
        if normalized_param in self.ignored_columns:
            return None
        if normalized_param.startswith("cyl_tmp_z"):
            return "cyl_tmp_z*"
        if normalized_param in self._normalized_rules:
            return normalized_param
        return self._alias_to_rule.get(normalized_param)

    def _apply_threshold_overrides(self, overrides: Dict[str, float]) -> None:
        for raw_param, threshold in overrides.items():
            normalized_param = self._normalize_name(raw_param)
            rule_key = self._resolve_rule_key(normalized_param)
            if not rule_key:
                continue
            if rule_key in self._normalized_rules:
                self._normalized_rules[rule_key]["threshold"] = float(threshold)

    def _resolve_target(
        self,
        normalized_param: str,
        rule_key: str,
        normalized_targets: Dict[str, Any],
    ) -> Optional[float]:
        candidate_keys = [normalized_param, rule_key]

        if rule_key == "dosage_time":
            candidate_keys.append("plasticizing_time")
        if rule_key == "switch_position":
            candidate_keys.append("switch_over_volume")
        if rule_key == "cyl_tmp_z*":
            candidate_keys.append("cyl_tmp_z")

        seen = set()
        for key in candidate_keys:
            if key in seen or not key:
                continue
            seen.add(key)
            value = self._to_float(normalized_targets.get(key))
            if value is not None:
                return value
        return None

    def check_safety(self, row: Dict[str, Any] | pd.Series, targets: Dict[str, Any]) -> Dict[str, Any]:
        """
        Evaluate live row values against target values.

        Returns a single worst-case result in the format:
        {
            "status": "OK|WARNING|CRITICAL",
            "message": "...",
            "tooltip": "...",
            "deviation": 0.45
        }
        """
        row_dict = row.to_dict() if isinstance(row, pd.Series) else dict(row)
        normalized_row = {self._normalize_name(k): v for k, v in row_dict.items()}
        normalized_targets = {self._normalize_name(k): v for k, v in dict(targets).items()}

        worst_result = {
            "status": "OK",
            "message": "",
            "tooltip": "",
            "deviation": 0.0,
        }
        severity_rank = {"OK": 0, "WARNING": 1, "CRITICAL": 2}

        # Long-form support: {"variable_name": "...", "value": ...}
        if "variable_name" in normalized_row and "value" in normalized_row:
            single_param = self._normalize_name(normalized_row.get("variable_name", ""))
            if single_param in self.ignored_columns:
                return {
                    "status": "SKIPPED",
                    "message": f"SKIPPED: {single_param} is excluded from monitoring.",
                    "tooltip": "",
                    "deviation": 0.0,
                }
            normalized_row = {single_param: normalized_row.get("value")}

        for normalized_param, live_raw in normalized_row.items():
            rule_key = self._resolve_rule_key(normalized_param)
            if rule_key is None:
                continue

            live_value = self._to_float(live_raw)
            if live_value is None:
                continue

            target_value = self._resolve_target(
                normalized_param=normalized_param,
                rule_key=rule_key,
                normalized_targets=normalized_targets,
            )
            if target_value is None:
                continue

            rule = self._normalized_rules.get(rule_key)
            if not rule:
                continue

            threshold = float(rule.get("threshold", 0.0))
            deviation = abs(live_value - target_value)
            if deviation <= threshold:
                continue

            status = str(rule.get("criticality", "WARNING")).upper()
            rule_message = str(rule.get("message", "")).strip()
            message = (
                f"{status}: {normalized_param} Deviation {deviation:.2f} exceeded "
                f"+/-{threshold:.2f} from target {target_value:.2f}. {rule_message}".strip()
            )
            tooltip = str(rule.get("tooltip", "")).strip()
            candidate = {
                "status": status,
                "message": message,
                "tooltip": tooltip,
                "deviation": round(float(deviation), 6),
            }

            current_rank = severity_rank.get(worst_result["status"], 0)
            candidate_rank = severity_rank.get(status, 1)
            if (
                candidate_rank > current_rank
                or (
                    candidate_rank == current_rank
                    and float(candidate["deviation"]) > float(worst_result["deviation"])
                )
            ):
                worst_result = candidate
                if status == "CRITICAL":
                    break

        return worst_result
